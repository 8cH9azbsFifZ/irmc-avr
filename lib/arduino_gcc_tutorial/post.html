<p>
Using the <a href="http://www.arduino.cc/en/Main/Software">Arduino IDE</a> or the <a href="http://www.liquidware.com/antipasto_arduino_ide">Antipasto IDE</a> can be limiting for serious development owing to their design being focused for computer newbies, abstracting away what is going on under the hood. This is especially pertinent when using the Antipasto IDE, for boards like the <a href="http://www.liquidware.com/shop/show/TSL/TouchShield+Slide">Liquidware Touchshield Slide</a>, because the IDE does not by default appear to support the adding of custom <tt>.cpp</tt> and <tt>.c</tt> files to the <tt>.pde</tt> source directory, forcing the use of a single <tt>.pde</tt> file, which is ridiculous. Furthermore, both IDEs force the user to stick the PDE in a directory of the same name. Perhaps there are some workarounds for these issues, but since I'm too lazy to RTFM I decided to write a makefile to compile and upload AVR programs to boards such as the Arduino.
</p>

<p>
This example will consider the <a href="http://arduino.cc/en/Main/ArduinoBoardUno">Arduino Uno</a> since this is a popular board. It will demonstrate how to create a static library using the Arduino source, which can be called upon to compile and upload custom c and c++ programs to the Arduino Uno. It is straightforward to modify this example for other boards, including the Mega1280 and the Touchshield Slide (I have done both). This explanation is written for FreeBSD and Linux users, similar steps can probably followed on Windows using win-avr and cygwin.
</p>

<p>
The first step in building an Arduino library is to obtain the src files for the Arduino board. You can get these <a href="https://github.com/arduino/Arduino/tree/master/hardware/arduino/cores/arduino">from git</a>, or from your own system if you've already installed the IDE (They'll be somewhere like <tt>/usr/local/arduino/hardware/cores/arduino/src/components/board</tt>. However they are obtained, put the src files into a directory of your choice. Alternatively you can save yourself the hassle and download this complete tutorial in a gzipped tar: <a href="/misc/arduino_gcc_tutorial.tar.gz">arduino_gcc_tutorial.tar.gz</a>
</p>

<p>
I'm going to assume arbitrarily, that you want to put headers in <tt>~/include/arduino</tt> and the Arduino library in <tt>~/lib</tt>, but of course you can put these wherever you want.
</p>

<p>
Since <a href="http://www.nongnu.org/avr-libc/">avr-libc</a> does not implement the C++ <a href="http://www.cplusplus.com/reference/std/new/operator%20new/">new</a> and <a href="http://www.cplusplus.com/reference/std/new/operator%20delete/">delete</a> operators, these shall be defined by us for convenience in two additional files: <tt>forward.h</tt> and <tt>forward.cpp</tt>.
</p>

<ol>
<li>
<tt>forward.h</tt>
<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#ff80ff">#pragma once</font><br>
<font color="#60ff60">extern</font>&nbsp;<font color="#ffa0a0">&quot;C&quot;</font>&nbsp;<font color="#60ff60">void</font>&nbsp;__cxa_pure_virtual(<font color="#60ff60">void</font>);<br>
__extension__ <font color="#60ff60">typedef</font>&nbsp;<font color="#60ff60">int</font>&nbsp;__guard __attribute__((mode (__DI__)));<br>
<font color="#60ff60">extern</font>&nbsp;<font color="#ffa0a0">&quot;C&quot;</font>&nbsp;<font color="#60ff60">int</font>&nbsp;__cxa_guard_acquire(__guard *g);<br>
<font color="#60ff60">extern</font>&nbsp;<font color="#ffa0a0">&quot;C&quot;</font>&nbsp;<font color="#60ff60">void</font>&nbsp;__cxa_guard_release (__guard *g);<br>
<font color="#60ff60">extern</font>&nbsp;<font color="#ffa0a0">&quot;C&quot;</font>&nbsp;<font color="#60ff60">void</font>&nbsp;__cxa_guard_abort (__guard *g);<br>
</div>
</li>

<br/>
<li>
<tt>forward.cpp</tt>
<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#ff80ff">#include </font><font color="#ffa0a0">&quot;forward.h&quot;</font><br>
<font color="#60ff60">void</font>&nbsp;__cxa_pure_virtual(<font color="#60ff60">void</font>) {}<br>
<font color="#60ff60">int</font>&nbsp;__cxa_guard_acquire(__guard *g) {<font color="#ffff00">return</font>&nbsp;!*(<font color="#60ff60">char</font>&nbsp;*)(g);};<br>
<font color="#60ff60">void</font>&nbsp;__cxa_guard_release (__guard *g) {*(<font color="#60ff60">char</font>&nbsp;*)g = <font color="#ffa0a0">1</font>;};<br>
<font color="#60ff60">void</font>&nbsp;__cxa_guard_abort (__guard *g) {}; <br>
</div>
</li>
</ol>

<p>
These should be placed in the same directory as the Arduino src so the listing looks like this:
</o>

<pre>
binary.h        HardwareSerial.cpp  Print.cpp    Tone.cpp          WInterrupts.c   wiring_digital.c
wiring_pulse.c  WProgram.h          forward.cpp  HardwareSerial.h  pins_arduino.c  Print.h    
WCharacter.h    wiring_analog.c     wiring.h     wiring_shift.c    WString.cpp     forward.h
main.cpp        pins_arduino.h      Stream.h     WConstants.h      wiring.c        wiring_private.h
WMath.cpp       WString.h
</pre>

<p>
Now for the Makefile. I'm using <a href="http://www.gnu.org/software/make/">GNU make</a> for no specific reason. On FreeBSD when installed this will be called &quot;gmake&quot;, as BSD already has its own make. So you'll have to type this unless you alias it. Since most Linux distros use the GNU tools, it's likely that on a Linux box you can just type &quot;make&quot;. Here is the Makefile:
</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">CC</font>=avr-gcc<br>
<font color="#40ffff">CXX</font>=avr-g++<br>
<font color="#40ffff">MCU</font>=-mmcu=atmega328p <br>
<font color="#40ffff">CPU_SPEED</font>=-DF_CPU=16000000UL<br>
<font color="#40ffff">CFLAGS</font>=<font color="#40ffff">$(MCU)</font>&nbsp;<font color="#40ffff">$(CPU_SPEED)</font>&nbsp;-Os -w<br>
<font color="#40ffff">BOARD</font>=arduino<br>
<font color="#40ffff">LIBNAME</font>=lib<font color="#40ffff">$(BOARD)</font>.a<br>
<font color="#40ffff">INCDIR</font>=~/include/<font color="#40ffff">$(BOARD)</font><br>
<br>
<font color="#40ffff">OBJECTS</font>=pins_arduino.o wiring.o wiring_analog.o wiring_digital.o <font color="#ffa500">\</font><br>
<font color="#ffa500">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>wiring_pulse.o wiring_shift.o HardwareSerial.o Print.o&nbsp;&nbsp; <font color="#ffa500">\</font><br>
<font color="#ffa500">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>Tone.o WMath.o WString.o WInterrupts.o forward.o<br>
<br>
<font color="#40ffff">default:</font>&nbsp;<font color="#40ffff">$(OBJECTS)</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; avr-ar rcs </font><font color="#40ffff">$(LIBNAME)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$^</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; mkdir -p </font><font color="#40ffff">$(INCDIR)</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; mkdir -p ~/lib/</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; cp *.h</font> <font color="#40ffff">$(INCDIR)</font><font color="#ffa0a0">/</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; mv </font><font color="#40ffff">$(LIBNAME)</font>&nbsp;<font color="#ffa0a0">~/lib/</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; rm *.o</font><br>
<br>
<font color="#40ffff">%.o :</font>&nbsp;<font color="#40ffff">%</font>.c<br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(CC)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$&lt;</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(CFLAGS)</font><font color="#ffa0a0">&nbsp;-c -o </font><font color="#40ffff">$@</font><br>
<br>
<font color="#40ffff">%.o :</font>&nbsp;<font color="#40ffff">%</font>.cpp<br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(CXX)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$&lt;</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(CFLAGS)</font><font color="#ffa0a0">&nbsp;-c -o </font><font color="#40ffff">$@</font><br>
</div>

<p>
When the <tt>make</tt> (or <tt>gmake</tt>) command is executed from the shell in the src directory the target named <b>default</b> is called. Now the <b>default</b> target depends on OBJECTS, which are all the object files required to build the Arduino library. These objects correspond to all the .c and .cpp files (except main.cpp which is no longer needed by us). Since <b>default</b> depends on these objects, and they do not presently exist, gmake tries to create them and looks for rules to create them. The rules which match are:
</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">%.o :</font>&nbsp;<font color="#40ffff">%</font>.c<br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(CC)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$&lt;</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(CFLAGS)</font><font color="#ffa0a0">&nbsp;-c -o </font><font color="#40ffff">$@</font><br>
<br>
<font color="#40ffff">%.o :</font>&nbsp;<font color="#40ffff">%</font>.cpp<br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(CXX)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$&lt;</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(CFLAGS)</font><font color="#ffa0a0">&nbsp;-c -o </font><font color="#40ffff">$@</font><br>
</div>

<p>
These are very similar to <a href="http://www.gnu.org/s/hello/manual/make/Rule-Syntax.html">rules</a> implicity defined by gmake, but they have been modified slightly. They are simple rules to create object files from <tt>.c</tt> and <tt>.cpp</tt> files respectively. To take the first rule as an example, it says: in order to create a <tt>%.o</tt> target, where <tt>%</tt> is a wildcard, check for a corresponding <tt>%.c</tt> dependency and perform the action specified on the following line. In this case, the action defined invokes the <tt>avr-gcc</tt> compiler upon the <a href="http://www.gnu.org/s/hello/manual/make/Automatic-Variables.html">automatic variable</a> <tt>$&lt;</tt>, which denotes the first dependency. For example, when the target <tt>wiring.o</tt> is substituted for <tt>%.o</tt>, the corresponding <tt>%.c</tt> is <tt>wiring.c</tt>. This is also the first dependency and so substitutes <tt>$&lt;</tt> as an argument to <tt>avr-gcc</tt>.
</p>

<p>
CFLAGS specifies the compiler flags, and is defined at the top of the Makefile:
</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">MCU</font>=-mmcu=atmega328p <br>
<font color="#40ffff">CPU_SPEED</font>=-DF_CPU=16000000UL<br>
<font color="#40ffff">CFLAGS</font>=<font color="#40ffff">$(MCU)</font>&nbsp;<font color="#40ffff">$(CPU_SPEED)</font>&nbsp;-Os -w<br>
</div>

<p>
The microcontroller (MCU) is specified with the -mmcu flag, and the CPU speed set to 16Mhz. The correct flags to use for a given Atmel MCU can be obtained by reading the manufacturers specification or by consulting Arduino's <a href="https://github.com/arduino/Arduino/blob/master/hardware/arduino/boards.txt">boards.txt</a>.
</p>

The flag <tt>-Os</tt> specifies that generated code should be optimised for size, note that speed optimisations are also performed upto <tt>gcc</tt>'s level 2 so long as they don't typically increase code size. The <tt>-w</tt> flag suppresses warnings (which I don't care about). The final flag which appears in the rule is <tt>-c</tt>, which tells <tt>avr-gcc</tt> not to link the object file. And finally, going back to the action line, <tt>-o</tt> specifies the desired name of the generated object file. In this case <tt>$@</tt> is used, which is another automatic variable which matches the file name of the target of the rule, i.e the object file matched, for example <tt>wiring.o</tt>.
</p>

<p>gmake will perform this process for all objects specified, using the second rule for C++ files, the only difference being that <tt>avr-g++</tt> is used instead of <tt>avr-gcc</tt>. Once all the objects are created, the <b>default</b> rule continues as follows:</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">default:</font>&nbsp;<font color="#40ffff">$(OBJECTS)</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; avr-ar rcs </font><font color="#40ffff">$(LIBNAME)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$^</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; mkdir -p </font><font color="#40ffff">$(INCDIR)</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; mkdir -p ~/lib/</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; cp *.h</font> <font color="#40ffff">$(INCDIR)</font><font color="#ffa0a0">/</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; mv </font><font color="#40ffff">$(LIBNAME)</font>&nbsp;<font color="#ffa0a0">~/lib/</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; rm *.o</font><br>
</div>

<p>
The <tt>avr-ar</tt> line creates an archive named LIBNAME containing all the object files matched by the automatic variable <tt>$^</tt>. This automatic variable matches all of the rule dependencies, i.e the variable OBJECTS in this case. The next two instructions make the directories: <tt>~/include/arduino</tt> and <tt>~/lib</tt>. The forth instruction copies all the header files into <tt>~/include/arduino</tt> so that they can be referenced later. The fifth instruction copies the generated archive <tt>libarduino.a</tt> into <tt>~/lib</tt> so it can be used later. The final instruction deletes the generated object files which are no longer needed once the archive has been constructed. The library has now been constructed and is ready to use.
</p>

<p>
To build a library for another target board, such as the <a href="http://arduino.cc/en/Main/ArduinoBoardMega">Arduino Mega</a> only the MCU and processor speed need to be changed accordingly.
</p>

<p>
Now that the library has been constructed, it is time to demonstrate how to link it against a real program, capable of being uploaded to the Arduino. Consider the following trivial example:
</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#ff80ff">#include </font><font color="#ffa0a0">&quot;WProgram.h&quot;</font><br>
<font color="#60ff60">void</font>&nbsp;setup() {<br>
&nbsp;&nbsp; pinMode(<font color="#ffa0a0">13</font>,OUTPUT);<br>
}<br>
<br>
<font color="#60ff60">void</font>&nbsp;loop() {<br>
&nbsp;&nbsp; digitalWrite(<font color="#ffa0a0">13</font>,HIGH);<br>
&nbsp;&nbsp; delay(<font color="#ffa0a0">100</font>);<br>
&nbsp;&nbsp; digitalWrite(<font color="#ffa0a0">13</font>,LOW);<br>
&nbsp;&nbsp; delay(<font color="#ffa0a0">100</font>);<br>
}<br>
<br>
<font color="#60ff60">int</font>&nbsp;main() {<br>
&nbsp;&nbsp; init();<br>
&nbsp;&nbsp; setup();<br>
&nbsp;&nbsp; <font color="#ffff00">while</font>(<font color="#ffa0a0">1</font>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop();<br>
}<br>
</div>

<p>Notice that the usual Arduino <tt>setup()</tt> and <tt>loop()</tt> functions have been maintained for convenience, but the real work is now being done by the <tt>main</tt> function familiar to any programmers of <tt>c</tt> or <tt>C++</tt>. The header file <tt>WProgram.h</tt> is needed to reference the Arduino function such as <tt>pinMode(13,OUTPUT)</tt> or whatever. The function init is needed by <tt>wiring.c</tt> in its setup. The main function can be reused like that and so there is very little difference between a <tt>.pde</tt> and a file like this. This program flashes the LED on pin 13 like the classic <tt>blink.pde</tt> example sketch that comes with the Arduino. To compile program, link it to the library created before, and upload it to the Arduino, the following makefile can be used:<p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">CXX</font>=avr-gcc<br>
<font color="#40ffff">INCLUDE</font>=-I ~/include/arduino/<br>
<font color="#40ffff">LIBS</font>=-L ~/lib -lm -larduino<br>
<font color="#40ffff">MCU</font>=-mmcu=atmega328p<br>
<font color="#40ffff">CPU_SPEED</font>=-DF_CPU=16000000UL<br>
<font color="#40ffff">CFLAGS</font>=<font color="#40ffff">$(MCU)</font>&nbsp;<font color="#40ffff">$(CPU_SPEED)</font>&nbsp;-Os -w -Wl,--gc-sections -ffunction-sections -fdata-sections<br>
<font color="#40ffff">PORT</font>=/dev/cuaU0 <font color="#80a0ff"># FreeBSD</font><br>
<font color="#ff80ff">ifeq</font>&nbsp;(<font color="#40ffff">$(</font><font color="#ffff00">shell</font><font color="#40ffff">&nbsp;uname)</font>,Linux)<br>
&nbsp;&nbsp; PORT=/dev/ttyACM0<br>
<font color="#ff80ff">endif</font><br>
<br>
<font color="#40ffff">default:</font>&nbsp;build upload<br>
<br>
<font color="#40ffff">build:</font>&nbsp;Test.hex<br>
<br>
<font color="#40ffff">Test.hex:</font>&nbsp;Test.elf<br>
<font color="#ffa0a0">&nbsp;&nbsp; avr-objcopy -O ihex </font><font color="#40ffff">$&lt;</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$@</font><br>
<br>
<font color="#40ffff">OBJS</font>= <font color="#80a0ff"># Put other objects here</font><br>
<font color="#40ffff">Test.elf:</font>&nbsp;Test.cpp <font color="#40ffff">$(OBJS)</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(CXX)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(CFLAGS)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(INCLUDE)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$^</font><font color="#ffa0a0">&nbsp;-o </font><font color="#40ffff">$@</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(LIBS)</font><br>
<br>
<font color="#40ffff">upload:</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; avrdude -V -F -p m328p -c arduino -b 115200 -Uflash:w:Test.hex -P</font><font color="#40ffff">$(PORT)</font><br>
<br>
<font color="#40ffff">clean:</font><br>
<font color="#ffa500">&nbsp;&nbsp; @</font><font color="#ffa0a0">echo -n Cleaning ...</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(</font><font color="#ffff00">shell</font><font color="#40ffff">&nbsp;rm Test.elf 2&gt; /dev/null)</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(</font><font color="#ffff00">shell</font><font color="#40ffff">&nbsp;rm Test.hex 2&gt; /dev/null)</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(</font><font color="#ffff00">shell</font><font color="#40ffff">&nbsp;rm *.o 2&gt; /dev/null)</font><br>
<font color="#ffa500">&nbsp;&nbsp; @</font><font color="#ffa0a0">echo </font><font color="#ffa0a0">&quot; done&quot;</font><br>
<br>
<font color="#40ffff">%.o:</font>&nbsp;<font color="#40ffff">%</font>.cpp<br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(CXX)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$&lt;</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(CFLAGS)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(INCLUDE)</font><font color="#ffa0a0">&nbsp;-c -o </font><font color="#40ffff">$@</font><br>
</div>

<p>
This time the <b>default</b> target depends on the <b>build</b> and <b>upload</b> targets, which means these will be called in turn. The <b>build</b> target depends on the file <tt>Test.hex</tt>. This is the hex file which will be uploaded to the Arduino over the USB to serial interface. This target depends on <tt>Test.elf</tt>, which is the actual gcc compiled object file. The target <tt>Test.elf</tt>, depends on <tt>Test.cpp</tt> and any other objects specified in the variable OBJECTS.
</p>

<p>
Objects specified in the OBJECTS variable will be compiled by the rule:
</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">%.o:</font>&nbsp;<font color="#40ffff">%</font>.cpp<br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(CXX)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$&lt;</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(CFLAGS)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(INCLUDE)</font><font color="#ffa0a0">&nbsp;-c -o </font><font color="#40ffff">$@</font><br>
</div>

<p>
Which is very similar to before. Once all objects are compiled, <tt>Test.elf</tt> is compiled using the rule:
</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">Test.elf:</font>&nbsp;Test.cpp <font color="#40ffff">$(OBJS)</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; </font><font color="#40ffff">$(CXX)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(CFLAGS)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(INCLUDE)</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$^</font><font color="#ffa0a0">&nbsp;-o </font><font color="#40ffff">$@</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$(LIBS)</font><br>
</div>

<p>
There are a few differences to the gmake rule described previously. First all the dependencies are pulled in using the automatic variable <tt>$^</tt> since there can be multiple inputs. And secondly the <tt>-c</tt> flag is NOT specified since it is desired to link the compiled executable to the dependent libraries. The compiler generates the compiled code and then tries to find any functions used. The places to look is specified using the flag <tt>-larduino</tt>, which causes the compiler to search for a library called <tt>libarduino.a</tt>. More generally, in this context, <tt>-lX</tt> causes the compiler to search for <tt>libX.a</tt>. The compiler searches for <tt>libarduino.a</tt> in several default locations as well as any specified using instances of the <tt>-L</tt> option, which in this case is set to <tt>~/lib</tt>, which is the directory the library was stored in earlier. Finally, observe that the CFLAGS variable is different:
</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">CFLAGS</font>=<font color="#40ffff">$(MCU)</font>&nbsp;<font color="#40ffff">$(CPU_SPEED)</font>&nbsp;-Os -w -Wl,--gc-sections -ffunction-sections -fdata-sections <br>
</div>

<p>
The only difference is the addition of a few new flags: 
</p>

<ul>
<li><tt>-Wl,--gc-sections</tt> This cuts out .o files which are not used.</li>
<li><tt>-ffunction-sections</tt> This makes it seem to the linker essentially as if each function were in its own <tt>.o</tt> file, so that <tt>--gc-sections</tt> argument is even better.</li>
<li><tt>-ffdata-sections</tt> This does for static and global variables what <tt>--ffunction-sections</tt> does for functions.</li>
</ul>

<p>
Once the <tt>Test.elf</tt> this rule is done, and the dependency for the <tt>Test.hex</tt> rule is satisfied, so it executes:
</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">Test.hex:</font>&nbsp;Test.elf<br>
<font color="#ffa0a0">&nbsp;&nbsp; avr-objcopy -O ihex </font><font color="#40ffff">$&lt;</font><font color="#ffa0a0">&nbsp;</font><font color="#40ffff">$@</font><br>
</div>

<p>
This straightforward rule invokes <tt>avr-objcopy</tt> to convert <tt>Test.elf</tt> into a format that can be recognised by the Arduino's bootloader (which accepts new programs via the USB to serial interface). The flag <tt>-o IHEX</tt> specifies the intel hexadecimal format accordingly. Note that there are several options available to <tt>avr-objcopy</tt> which are claimed to reduce hex file size, which can be useful since these boards don't have a lot of FLASH. I tried a few but it didn't seem to make any difference, so I haven't bothered with them. That's the build target finished, which means that make goes onto the <b>upload</b> target.
</p>

<p>
The <b>upload</b> target flashes the hex file <tt>Test.hex</tt> to the Arduino using <tt>avrdude</tt>:
</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">upload:</font><br>
<font color="#ffa0a0">&nbsp;&nbsp; avrdude -V -F -p m328p -c arduino -b 115200 -Uflash:w:Test.hex -P</font><font color="#40ffff">$(PORT)</font><br>
</div>

<p>The flags are as follows</p>

<ul>
<li><tt>-V</tt> Disables automatic verify check upon uploading. Roughly halves the upload time, since the serial interface is used to re-read the uploaded program for verification.</li>
<li><tt>-F</tt> Do not try to verify the device signature. They say the sig can get overwritten, hasn't happened to me, but we know what the device is anyway so who cares. </li>
<li><tt>-p m328p</tt> Specifies the MCU, in this case ATmega328P, see the manpage for a list.</li>
<li><tt>-c arduino</tt> Programmer ID, specifies the pin configuration for use in serial communication with the Arduino.</li>
<li><tt>-b 115200</tt> The serial baud rate (symbols per second) to use when communicating with the Arduino.</li>
<li><tt>-Uflash:w:Test.hex</tt> This says to perform a memory operation (<tt>-U</tt>) on the <tt>flash</tt> memory of the Arduin and specifically perform a write operation (<tt>w</tt>) with the file <tt>Test.hex</tt></li>
<li><tt>-P$(PORT)</tt> This specifies the serial port to use to communicate with the Arduino.</li>
</ul>

<p>Most of the values from these options I obtained from <a href="https://github.com/arduino/Arduino/blob/master/hardware/arduino/boards.txt">boards.txt</a> but one could also refer to the MCU manufacturers specifications. Notice that I've also included some code to choose the port based on platform (only FreeBSD and Linux):</p>

<div style="background-color:#000000; font:14pt monospace; color:#cccccc" text="#cccccc">
<font color="#40ffff">PORT</font>=/dev/cuaU0 <font color="#80a0ff"># FreeBSD</font><br>
<font color="#ff80ff">ifeq</font>&nbsp;(<font color="#40ffff">$(</font><font color="#ffff00">shell</font><font color="#40ffff">&nbsp;uname)</font>,Linux)<br>
&nbsp;&nbsp; PORT=/dev/ttyACM0<br>
<font color="#ff80ff">endif</font><br>
</div>

<p>
Different boards require different options, and FTDI devices can appear on a different port such as <tt>/dev/ttyUSB0</tt>. But you should easily be able to figure out how to work with any of the common boards given this framework, so I'll leave the generalisation as an exercise for the reader... (or in otherwords, I'm too lazy since I don't need it for my purposes). Incidentally, laziness gets you everywhere in programming. Whilst one cannot be so lazy so as to do nothing, having taken up the challenge, the lazy programmer takes the most efficient and direct path to completion. The lazy programmer also produces speedy code, because he cannot be bothered to wait long for his programs to start, and he hates waiting for them to finish doing their jobs.
</p>
